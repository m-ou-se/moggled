<!doctype html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>moggle.core.vao</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head><body>
<h1><a href="index.html">Moggle</a></h1>
<h2>moggle.core.vao</h2>
<!-- Generated by Ddoc from source/moggle/core/vao.d -->
<br><br>
<dl><dt class="d_decl"><a name=".Vao"></a>struct <a name="Vao"></a><span class="ddoc_psymbol">Vao</span>;
</dt>
<dd>A vertex attribute object.
<br><br>
This is a wrapper around a GLuint generated by glGenVertexArrays(1, &id).
Initially, this id is 0.
glGenVertexArrays is automatically called the first time bind() is called.<br><br>

<dl><dt class="d_decl"><a name=".Vao.id"></a>const @property GLuint <a name="id"></a><span class="ddoc_psymbol">id</span>();
</dt>
<dd>The <a name="id"></a><span class="ddoc_psymbol">id</span> of this Vao, or 0 if it is not yet created in OpenGL.<br><br>

</dd>
<dt class="d_decl"><a name=".Vao.created"></a>const @property bool <a name="created"></a><span class="ddoc_psymbol">created</span>();
<br><a name=".Vao.opCast"></a>const bool <a name="opCast"></a><span class="ddoc_psymbol">opCast</span>(T : bool)();
</dt>
<dd>Check if this Vao is already <a name="created"></a><span class="ddoc_psymbol">created</span> in OpenGL.<br><br>

</dd>
<dt class="d_decl"><a name=".Vao.create"></a>void <a name="create"></a><span class="ddoc_psymbol">create</span>();
</dt>
<dd>Force the creation of a OpenGL Vao, or do nothing if already created. (Calls glGenVertexArrays.)<br><br>

</dd>
<dt class="d_decl"><a name=".Vao.destroy"></a>void <a name="destroy"></a><span class="ddoc_psymbol">destroy</span>();
</dt>
<dd>Destroy the OpenGL Vao and reset the id back to 0. (Calls glDeleteVertexArrays.)<br><br>

</dd>
<dt class="d_decl"><a name=".Vao.bind"></a>void <a name="bind"></a><span class="ddoc_psymbol">bind</span>();
</dt>
<dd>Create the OpenGL Vao, if needed, and <a name="bind"></a><span class="ddoc_psymbol">bind</span> it. (Calls glBindVertexArray.)<br><br>

</dd>
<dt class="d_decl"><a name=".Vao.setAttribute"></a>void <a name="setAttribute"></a><span class="ddoc_psymbol">setAttribute</span>()(GLuint <i>index</i>, ref GenericVbo <i>vbo</i>, AttributeParameters <i>parameters</i>);
<br>void <a name="setAttribute"></a><span class="ddoc_psymbol">setAttribute</span>(T)(GLuint <i>index</i>, ref SpecificVbo!T <i>vbo</i>);
</dt>
<dd>Add or change an attribute. (Calls glEnableVertexAttribArray and glVertexAttribPointer.)
<br><br>
The second version automatically deduces the <i>parameters</i> for
	glVertexAttribPointer using attributeParametersFor!T.<br><br>

</dd>
<dt class="d_decl"><a name=".Vao.disableAttribute"></a>void <a name="disableAttribute"></a><span class="ddoc_psymbol">disableAttribute</span>(GLuint <i>index</i>);
</dt>
<dd>Disable an attribute. (Calls glDisableVertexAttribArray.)<br><br>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".AttributeParameters"></a>alias <a name="AttributeParameters"></a><span class="ddoc_psymbol">AttributeParameters</span> = (int, uint, bool, int, const(void)*);
</dt>
<dd>The tuple of parameters for glVertexAttribPointer that specify the type information.
<br><br>
The parameters are:
<br><br>

<ul>	<li>The size of the matrix/vector, or 1 for single elements.</li>
	<li>The type of the elements. (One of GL_FLOAT, GL_INT, etc.)</li>
	<li>Whether the integral type is normalized (<b>true</b>) or not (<b>false</b>).</li>
	<li>The stride, the distance in bytes to the next element.</li>
	<li>The offset from the beginning of the buffer.</li>
</ul>
<br><br>

You should check the documentation of glVertexAttribPointer for their details.<br><br>

</dd>
<dt class="d_decl"><a name=".attributeParametersFor"></a>template <a name="attributeParametersFor"></a><span class="ddoc_psymbol">attributeParametersFor</span>(T)<br>template <a name="attributeParametersFor"></a><span class="ddoc_psymbol">attributeParametersFor</span>(T, string member) if (is(T == struct))</dt>
<dd>The (automatically deduced) correct AttributeParameters for T.
<br><br>
Works for GLdouble, GLfloat, GLint, GLuint, GLshort, GLushort, GLbyte, GLubyte,
Normalized versions of these, and Matrices, Vectors and HVectors of all these.
<br><br>

The second version takes the name the member of T, for when the buffer contains
an array of T but only a single member of that T is what you want parameters for.
This automatically sets the stride and the offset to to the correct values
(T.sizeof and T.member.offsetof, respectively).

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=green>// These two lines do the exact same.
</font>glVertexAttribPointer(1, <u>attributeParametersFor</u>!<font color=blue>int</font>);
glVertexAttribPointer(1, 1, GL_INT, <font color=blue>false</font>, <font color=blue>int</font>.sizeof, <font color=blue>null</font>);
</pre>
<pre class="d_code"><font color=green>// These two lines do the exact same.
</font>glVertexAttribPointer(1, <u>attributeParametersFor</u>!Matrix3f);
glVertexAttribPointer(1, 9, GL_FLOAT, <font color=blue>false</font>, Matrix3f.sizeof, <font color=blue>null</font>);
</pre>
<pre class="d_code"><font color=green>// These two lines do the exact same.
</font>glVertexAttribPointer(1, <u>attributeParametersFor</u>!(Vector!(Normalized!<font color=blue>ubyte</font>, 4)));
glVertexAttribPointer(1, 4, GL_UBYTE, <font color=blue>true</font>, Vector!(Normalized!<font color=blue>ubyte</font>, 4).sizeof, <font color=blue>null</font>);
</pre>
<pre class="d_code"><font color=blue>struct</font> Vertex { HVector4f position; Vector3f normal; HVector4f color; }
<font color=green>// These two lines do the exact same.
</font>glVertexAttribPointer(1, <u>attributeParametersFor</u>!(Vertex, <font color=red>"normal"</font>));
glVertexAttribPointer(1, 3, GL_FLOAT, <font color=blue>false</font>, Vertex.size, <font color=blue>cast</font>(<font color=blue>const</font>(<font color=blue>void</font>)*)Vertex.normal.offsetof);
</pre>
<br><br>

</dd>
</dl>

</body></html>
