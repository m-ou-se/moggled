module moggle.core.vao;

import std.typetuple;

import moggle.core.gl;
import moggle.core.vbo;
import moggle.math.matrix;
import moggle.math.normalized;

/++ A vertex attribute object.

This is a wrapper around a GLuint generated by glGenVertexArrays(1, &id).
Initially, this id is 0.
glGenVertexArrays is automatically called the first time bind() is called.
+/
struct Vao {

	private GLuint id_ = 0;

	/// The id of this Vao, or 0 if it is not yet created in OpenGL.
	@property GLuint id() const { return id_; }

	/// Check if this Vao is already created in OpenGL.
	@property bool created() const { return id != 0; }

	/// ditto
	bool opCast(T : bool)() const { return created; }

	/// Force the creation of a OpenGL Vao, or do nothing if already created.
	void create() {
		if (!id_) glGenVertexArrays(1, &id_);
		assert(id_, "glGenVertexArrays did not generate a vertex array.");
	}

	/// Destroy the OpenGL Vao and reset the id back to 0.
	void destroy() {
		glDeleteVertexArrays(1, &id_);
		id_ = 0;
	}

	/// ditto
	~this() { destroy(); }

	/// Create the OpenGL Vao, if needed, and call glBindVertexArray on it.
	void bind() {
		create();
		glBindVertexArray(id_);
	}

	@disable this(this);

	/** Add or change an attribute.

	This calls glEnableVertexAttribArray and glVertexAttribPointer.

	The second version automatically deduces the parameters for
	glVertexAttribPointer using attributeParametersFor!T.
	*/
	void attribute()(GLuint index, ref GenericVbo vbo, AttributeParameters parameters) {
		bind();
		vbo.bind(GL_ARRAY_BUFFER);
		glEnableVertexAttribArray(index);
		glVertexAttribPointer(index, parameters);
	}

	/// ditto
	void attribute(T)(GLuint index, ref SpecificVbo!(T) vbo) {
		attribute(index, vbo, attributeParametersFor!T);
	}

}

/++ The tuple of parameters for glVertexAttribPointer that specify the type information.

The parameters are:

$(UL
	$(LI The size of the matrix/vector, or 1 for single elements.)
	$(LI The type of the elements. (One of GL_FLOAT, GL_INT, etc.))
	$(LI Whether the integral type is normalized (true) or not (false).)
	$(LI The stride, the distance in bytes to the next element.)
	$(LI The offset from the beginning of the buffer.)
)

You should check the documentation of glVertexAttribPointer for their details.
+/
alias TypeTuple!(GLint, GLenum, bool, GLsizei, const(void)*) AttributeParameters;

/++ The (automatically deduced) correct AttributeParameters for T.

Works for GLdouble, GLfloat, GLint, GLuint, GLshort, GLushort, GLbyte, GLubyte,
Normalized versions of these, and Matrices, Vectors and HVectors of all these.

Examples:
---
// These two lines do the exact same.
glVertexAttribPointer(1, attributeParametersFor!int);
glVertexAttribPointer(1, 1, GL_INT, false, int.sizeof, null);
---
---
// These two lines do the exact same.
glVertexAttribPointer(1, attributeParametersFor!Matrix3f);
glVertexAttribPointer(1, 9, GL_FLOAT, false, Matrix3f.sizeof, null);
---
---
// These two lines do the exact same.
glVertexAttribPointer(1, attributeParametersFor!(Vector!(Normalized!ubyte, 4)));
glVertexAttribPointer(1, 4, GL_UBYTE, true, Vector!(Normalized!ubyte, 4).sizeof, null);
---
+/
template attributeParametersFor(T) {
	static if (is(T == HVector!(E, N), E, size_t N)) {
		alias E element_type;
		enum size = N;
	} else static if (is(T == Matrix!(E, N, M), E, size_t N, size_t M)) {
		alias E element_type;
		enum size = N * M;
	} else {
		alias T element_type;
		enum size = 1;
	}
	enum normalized = is(element_type == Normalized!(base_type), base_type);
	static if (!normalized) alias element_type base_type;
	alias TypeTuple!(size, GL_type!base_type, normalized, T.sizeof, null) attributeParametersFor;
}

