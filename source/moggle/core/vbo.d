module moggle.core.vbo;

import moggle.core.gl;

/++ A vertex buffer object.

This is a wrapper around a GLuint generated by glGenBuffers(1, &id).
Initially, this id is 0.
glGenBuffers is automatically called the first time bind() is called.

Vbo!void is an alias of this.
+/
struct GenericVbo {

	private GLuint id_ = 0;

	/// The id of this Vao, or 0 if it is not yet created in OpenGL.
	@property GLuint id() const { return id_; }

	/// Check if this Vao is already created in OpenGL.
	@property bool created() const { return id != 0; }

	/// ditto
	bool opCast(T : bool)() const { return created; }

	/// Force the creation of a OpenGL Vbo, or do nothing if already created. (Calls glGenBuffers.)
	void create() {
		if (!id_) glGenBuffers(1, &id_);
		assert(id_, "glGenBuffers did not generate a buffer.");
	}

	/// Destroy the OpenGL Vbo and reset the id back to 0. (Calls glDeleteBuffers.)
	void destroy() {
		glDeleteBuffers(1, &id_);
		id_ = 0;
	}

	// ditto
	~this() {
		destroy();
	}

	/// Create the OpenGL Vbo, if needed, and bind it. (Calls glBindBuffer.)
	void bind(GLenum buffer) {
		create();
		glBindBuffer(buffer, id_);
	}

	/// Cast this GenericVbo to a specific SpecificVbo!T.
	ref inout(SpecificVbo!(T)) opCast(T : SpecificVbo!(T))() inout {
		return *cast(typeof(return)*)&this;
	}

	@disable this(this);

}

/++ A Vbo that knows what type of elements are stored in it.

Vbo!T is an alias of this, except for Vbo!void (which is an alias for GenericVbo).

Contains a single GenericVbo, which is aliased as this.
(Which basically means that any SpecificVbo!T is also a GenericVbo.)
+/
struct SpecificVbo(T) {

	GenericVbo vbo_;

	alias vbo_ this;

	/++ Store the given data in the Vbo. (Calls glBufferData.)

	Examples:
	---
	auto v = Vbo!int([1, 2, 3, 4, 5]);
	v.data([2, 1, 0]); // Updates the Vbo with new data.
	---
	+/
	this(T[] data_, GLenum usage = GL_STATIC_DRAW) {
		data(data_, usage);
	}
	/// ditto
	void data(T[] data_, GLenum usage = GL_STATIC_DRAW) {
		bind(GL_ARRAY_BUFFER);
		glBufferData(GL_ARRAY_BUFFER, data_.length * T.sizeof, data_.ptr, usage);
	}

	/++ Allocate a OpenGL Vbo with space for n elements. (Calls glBufferData with null.)

	The contents of the Vbo are uninitialized and thus undefined.
	+/
	this(size_t n, GLenum usage = GL_STATIC_DRAW) {
		resize(n, usage);
	}
	/// ditto
	void resize(size_t size_, GLenum usage = GL_STATIC_DRAW) {
		bind(GL_ARRAY_BUFFER);
		glBufferData(GL_ARRAY_BUFFER, size_ * T.sizeof, null, usage);
	}

	/// The number of elements stored in this Vbo. (Calls glGetBufferParameteriv with GL_BUFFER_SIZE.)
	size_t size() {
		GLint s;
		bind(GL_ARRAY_BUFFER);
		glGetBufferParameteriv(GL_ARRAY_BUFFER, GL_BUFFER_SIZE, &s);
		return s / T.sizeof;
	}

	/// Calls resize(0).
	void clear(GLenum usage = GL_STATIC_DRAW) {
		resize(0, usage);
	}

	/++ Map the contents of the Vbo in our own memory, temporarily. (Calls glMapBuffer.)

	Returns: An object that behaves like a T[] (or const(T)[], for the read-only version),
	and reflects the contents of the Vbo.
	After this object is destructed, slices in that piece of memory are no longer valid
	(because glUnmapBuffer is then called).

	Examples:
	---
	auto v = Vbo!int(3);
	{
		auto m = v.mapWriteOnly();
		m[] = 5;
		m[1] = 2;
	}
	assert(v.mapReadOnly()[] == [5, 2, 5]);
	---
	+/
	auto mapReadOnly() {
		bind(GL_ARRAY_BUFFER);
		auto p = cast(const T *) glMapBuffer(GL_ARRAY_BUFFER, GL_READ_ONLY);
		return VboMapping!(const T)(p[0..size()]);
	}

	/// ditto
	auto mapWriteOnly() {
		bind(GL_ARRAY_BUFFER);
		auto p = cast(T *) glMapBuffer(GL_ARRAY_BUFFER, GL_READ_ONLY);
		return VboMapping!(T)(p[0..size()]);
	}

	/// ditto
	auto mapReadWrite() {
		bind(GL_ARRAY_BUFFER);
		auto p = cast(T *) glMapBuffer(GL_ARRAY_BUFFER, GL_READ_WRITE);
		return VboMapping!(T)(p[0..size()]);
	}

}

/// An alias for SpecificVbo!T, except that Vbo!void is an alias for GenericVbo.
template Vbo(T) {
	static if (is(T == void)) {
		alias GenericVbo Vbo;
	} else {
		alias SpecificVbo!T Vbo;
	}
}

struct VboMapping(T) {

	private T[] data_;

	@property T[] data() { return data_; }

	alias data this;

	@disable this(this);

	~this() {
		glUnmapBuffer(GL_ARRAY_BUFFER);
	}
}

