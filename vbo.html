<!doctype html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>moggle.core.vbo</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head><body>
<h1><a href="index.html">Moggle</a></h1>
<h2>moggle.core.vbo</h2>
<!-- Generated by Ddoc from moggle/core/vbo.d -->
<br><br>
<dl><dt class="d_decl"><a name=".GenericVbo"></a>struct <a name="GenericVbo"></a><span class="ddoc_psymbol">GenericVbo</span>;
</dt>
<dd>A vertex buffer object.
<br><br>
This is a wrapper around a GLuint generated by glGenBuffers(1, &id).
Initially, this id is 0.
glGenBuffers is automatically called the first time bind() is called.
<br><br>

Vbo!void is an alias of this.<br><br>

<dl><dt class="d_decl"><a name=".GenericVbo.id"></a>const @property GLuint <a name="id"></a><span class="ddoc_psymbol">id</span>();
</dt>
<dd>The <a name="id"></a><span class="ddoc_psymbol">id</span> of this Vao, or 0 if it is not yet created in OpenGL.<br><br>

</dd>
<dt class="d_decl"><a name=".GenericVbo.created"></a>const @property bool <a name="created"></a><span class="ddoc_psymbol">created</span>();
<br><a name=".GenericVbo.opCast"></a>const bool <a name="opCast"></a><span class="ddoc_psymbol">opCast</span>(T : bool)();
</dt>
<dd>Check if this Vao is already <a name="created"></a><span class="ddoc_psymbol">created</span> in OpenGL.<br><br>

</dd>
<dt class="d_decl"><a name=".GenericVbo.create"></a>void <a name="create"></a><span class="ddoc_psymbol">create</span>();
</dt>
<dd>Force the creation of a OpenGL Vbo, or do nothing if already created.<br><br>

</dd>
<dt class="d_decl"><a name=".GenericVbo.destroy"></a>void <a name="destroy"></a><span class="ddoc_psymbol">destroy</span>();
</dt>
<dd>Destroy the OpenGL Vbo and reset the id back to 0.<br><br>

</dd>
<dt class="d_decl"><a name=".GenericVbo.bind"></a>void <a name="bind"></a><span class="ddoc_psymbol">bind</span>(GLenum <i>buffer</i>);
</dt>
<dd>Create the OpenGL Vbo, if needed, and call glBindBuffer on it.<br><br>

</dd>
<dt class="d_decl"><a name=".GenericVbo.opCast"></a>inout inout(SpecificVbo!(T)) <a name="opCast"></a><span class="ddoc_psymbol">opCast</span>(T : SpecificVbo!(T))();
</dt>
<dd>Cast this GenericVbo to a specific SpecificVbo!T.<br><br>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".SpecificVbo"></a>struct <a name="SpecificVbo"></a><span class="ddoc_psymbol">SpecificVbo</span>(T);
</dt>
<dd>A Vbo that knows what type of elements are stored in it.
<br><br>
Vbo!T is an alias of this, except for Vbo!void (which is an alias for GenericVbo).
<br><br>

Contains a single GenericVbo, which is aliased as this.
(Which basically means that any <a name="SpecificVbo"></a><span class="ddoc_psymbol">SpecificVbo</span>!T is also a GenericVbo.)<br><br>

<dl><dt class="d_decl"><a name=".this"></a> this(T[] <i>data_</i>, GLenum <i>usage</i> = GL_STATIC_DRAW);
<br><a name=".data"></a>void <a name="data"></a><span class="ddoc_psymbol">data</span>(T[] <i>data_</i>, GLenum <i>usage</i> = GL_STATIC_DRAW);
</dt>
<dd>Store the given data in the Vbo.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> v = Vbo!<font color=blue>int</font>([1, 2, 3, 4, 5]);
v.data([2, 1, 0]); <font color=green>// Updates the Vbo with new data.
</font></pre>
<br><br>

</dd>
<dt class="d_decl"><a name=".this"></a> this(size_t <i>n</i>, GLenum <i>usage</i> = GL_STATIC_DRAW);
<br><a name=".resize"></a>void <a name="resize"></a><span class="ddoc_psymbol">resize</span>(size_t <i>size_</i>, GLenum <i>usage</i> = GL_STATIC_DRAW);
</dt>
<dd>Allocate a OpenGL Vbo with space for <i>n</i> elements.
<br><br>
The contents of the Vbo are uninitialized and thus undefined.<br><br>

</dd>
<dt class="d_decl"><a name=".size"></a>size_t <a name="size"></a><span class="ddoc_psymbol">size</span>();
</dt>
<dd>The number of elements stored in this Vbo.
<br><br>
Uses glGetBufferParameteriv with GL_BUFFER_SIZE, and therefore bind()s this Vbo as GL_ARRAY_BUFFER.<br><br>

</dd>
<dt class="d_decl"><a name=".clear"></a>void <a name="clear"></a><span class="ddoc_psymbol">clear</span>(GLenum <i>usage</i> = GL_STATIC_DRAW);
</dt>
<dd>Calls resize(0).<br><br>

</dd>
<dt class="d_decl"><a name=".mapReadOnly"></a>auto <a name="mapReadOnly"></a><span class="ddoc_psymbol">mapReadOnly</span>();
<br><a name=".mapWriteOnly"></a>auto <a name="mapWriteOnly"></a><span class="ddoc_psymbol">mapWriteOnly</span>();
<br><a name=".mapReadWrite"></a>auto <a name="mapReadWrite"></a><span class="ddoc_psymbol">mapReadWrite</span>();
</dt>
<dd>Map the contents of the Vbo in our own memory, temporarily
<br><br>
Will return an object that behaves like a T[] (or const(T)[], for the read-only version),
	and reflects the contents of the Vbo.
	After this object is destructed, slices in that piece of memory are no longer valid.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> v = Vbo!<font color=blue>int</font>(3);
{
	<font color=blue>auto</font> m = v.mapWriteOnly();
	m[] = 5;
	m[1] = 2;
}
<font color=blue>assert</font>(v.<u>mapReadOnly</u>()[] == [5, 2, 5]);
</pre>
<br><br>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Vbo"></a>template <a name="Vbo"></a><span class="ddoc_psymbol">Vbo</span>(T)</dt>
<dd>An alias for SpecificVbo!T, except that <a name="Vbo"></a><span class="ddoc_psymbol">Vbo</span>!void is an alias for GenericVbo.<br><br>

</dd>
</dl>

</body></html>
