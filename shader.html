<!doctype html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>moggle.core.shader</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head><body>
<h1><a href="index.html">Moggle</a></h1>
<h2>moggle.core.shader</h2>
<!-- Generated by Ddoc from moggle/core/shader.d -->
<br><br>
<dl><dt class="d_decl"><a name=".ShaderType"></a>enum <a name="ShaderType"></a><span class="ddoc_psymbol">ShaderType</span>;
</dt>
<dd>The type of a Shader.<br><br>

<dl><dt class="d_decl"><a name=".ShaderType.vertex"></a><a name="vertex"></a><span class="ddoc_psymbol">vertex</span></dt>
<dd>A <a name="vertex"></a><span class="ddoc_psymbol">vertex</span> shader (GL_VERTEX_SHADER).<br><br>

</dd>
<dt class="d_decl"><a name=".ShaderType.fragment"></a><a name="fragment"></a><span class="ddoc_psymbol">fragment</span></dt>
<dd>A <a name="fragment"></a><span class="ddoc_psymbol">fragment</span> shader (GL_FRAGMENT_SHADER).<br><br>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Shader"></a>struct <a name="Shader"></a><span class="ddoc_psymbol">Shader</span>;
</dt>
<dd>An OpenGL shader.
<br><br>
This is a wrapper around a GLuint created by glCreateShader(type).<br><br>

<dl><dt class="d_decl"><a name=".Shader.id"></a>const @property GLuint <a name="id"></a><span class="ddoc_psymbol">id</span>();
</dt>
<dd>Ths <a name="id"></a><span class="ddoc_psymbol">id</span> of this Shader, or 0 if it is not yet created in OpenGL.<br><br>

</dd>
<dt class="d_decl"><a name=".Shader.created"></a>const @property bool <a name="created"></a><span class="ddoc_psymbol">created</span>();
<br><a name=".Shader.opCast"></a>const bool <a name="opCast"></a><span class="ddoc_psymbol">opCast</span>(T : bool)();
</dt>
<dd>Check if this Shader is already <a name="created"></a><span class="ddoc_psymbol">created</span> in OpenGL.<br><br>

</dd>
<dt class="d_decl"><a name=".Shader.this"></a> this(ShaderType <i>t</i>);
<br><a name=".Shader.create"></a>void <a name="create"></a><span class="ddoc_psymbol">create</span>(ShaderType <i>t</i>);
</dt>
<dd>Create a shader of the specified type.
<br><br>
If the shader is already created, nothing will happen
	if it is of the same type, or it is destroyed and (re)created
	if it is of a different type.<br><br>

</dd>
<dt class="d_decl"><a name=".Shader.fromSource"></a>static Shader <a name="fromSource"></a><span class="ddoc_psymbol">fromSource</span>(ShaderType <i>t</i>, const(char)[] <i>source_code</i>);
</dt>
<dd>Create, load, and compile a shader directly from source code.<br><br>

</dd>
<dt class="d_decl"><a name=".Shader.fromFile"></a>static Shader <a name="fromFile"></a><span class="ddoc_psymbol">fromFile</span>(ShaderType <i>t</i>, in char[] <i>file_name</i>);
</dt>
<dd>Create, load, and compile a shader directly from a file.<br><br>

</dd>
<dt class="d_decl"><a name=".Shader.destroy"></a>void <a name="destroy"></a><span class="ddoc_psymbol">destroy</span>();
</dt>
<dd>Destroy the OpenGL Shader and reset the id back to 0.<br><br>

</dd>
<dt class="d_decl"><a name=".Shader.type"></a>const ShaderType <a name="type"></a><span class="ddoc_psymbol">type</span>();
</dt>
<dd>The <a name="type"></a><span class="ddoc_psymbol">type</span> of this shader.<br><br>

</dd>
<dt class="d_decl"><a name=".Shader.load"></a>void <a name="load"></a><span class="ddoc_psymbol">load</span>(const(char)[] <i>source_code</i>);
</dt>
<dd>Load the source code for the shader.<br><br>

</dd>
<dt class="d_decl"><a name=".Shader.try_compile"></a>void <a name="try_compile"></a><span class="ddoc_psymbol">try_compile</span>();
</dt>
<dd>Try to compile the Shader, check compiled() to see if it succeeded.<br><br>

</dd>
<dt class="d_decl"><a name=".Shader.compile"></a>void <a name="compile"></a><span class="ddoc_psymbol">compile</span>();
</dt>
<dd>Try to <a name="compile"></a><span class="ddoc_psymbol">compile</span>, and throw if it didn't succeed.
<br><br>
<b>Throws:</b><br>
ShaderCompilationError containing the error log on failure.<br><br>

</dd>
<dt class="d_decl"><a name=".Shader.compiled"></a>const bool <a name="compiled"></a><span class="ddoc_psymbol">compiled</span>();
</dt>
<dd>Check if the Shader is succesfully <a name="compiled"></a><span class="ddoc_psymbol">compiled</span>.<br><br>

</dd>
<dt class="d_decl"><a name=".Shader.log"></a>const string <a name="log"></a><span class="ddoc_psymbol">log</span>();
</dt>
<dd>The <a name="log"></a><span class="ddoc_psymbol">log</span> of errors for when compilation fails.<br><br>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".ShaderProgram"></a>struct <a name="ShaderProgram"></a><span class="ddoc_psymbol">ShaderProgram</span>;
</dt>
<dd>An OpenGL shader program.
<br><br>
This is a wrapper around a GLuint created by glCreateProgram().
Initially, this id is 0.
glCreateProgram is automatically called the first time anything is done with the object.<br><br>

<dl><dt class="d_decl"><a name=".ShaderProgram.id"></a>const @property GLuint <a name="id"></a><span class="ddoc_psymbol">id</span>();
</dt>
<dd>Ths <a name="id"></a><span class="ddoc_psymbol">id</span> of this ShaderProgram, or 0 if it is not yet created in OpenGL.<br><br>

</dd>
<dt class="d_decl"><a name=".ShaderProgram.created"></a>const @property bool <a name="created"></a><span class="ddoc_psymbol">created</span>();
<br><a name=".ShaderProgram.opCast"></a>const bool <a name="opCast"></a><span class="ddoc_psymbol">opCast</span>(T : bool)();
</dt>
<dd>Check if this ShaderProgram is already <a name="created"></a><span class="ddoc_psymbol">created</span> in OpenGL.<br><br>

</dd>
<dt class="d_decl"><a name=".ShaderProgram.create"></a>void <a name="create"></a><span class="ddoc_psymbol">create</span>();
</dt>
<dd>Force the creation of a OpenGL ShaderProgram, or do nothing if already created. (Calls glCreateProgram.)<br><br>

</dd>
<dt class="d_decl"><a name=".ShaderProgram.destroy"></a>void <a name="destroy"></a><span class="ddoc_psymbol">destroy</span>();
</dt>
<dd>Destroy the OpenGL Vao and reset the id back to 0. (Calls glDeleteProgram.)<br><br>

</dd>
<dt class="d_decl"><a name=".ShaderProgram.clear"></a>void <a name="clear"></a><span class="ddoc_psymbol">clear</span>();
</dt>
<dd>destroy() and create().<br><br>

</dd>
<dt class="d_decl"><a name=".ShaderProgram.attach"></a>void <a name="attach"></a><span class="ddoc_psymbol">attach</span>(ref const Shader <i>shader</i>);
</dt>
<dd>Attach a Shader to this program. (Calls glAttachShader.)<br><br>

</dd>
<dt class="d_decl"><a name=".ShaderProgram.bindAttribute"></a>void <a name="bindAttribute"></a><span class="ddoc_psymbol">bindAttribute</span>(GLuint <i>attribute</i>, const(char)* <i>name</i>);
</dt>
<dd>Bind an <i>attribute</i> <i>name</i> to a location. (Calls glBindAttribLocation.)<br><br>

</dd>
<dt class="d_decl"><a name=".ShaderProgram.tryLink"></a>void <a name="tryLink"></a><span class="ddoc_psymbol">tryLink</span>();
</dt>
<dd>Try to link the ShaderProgram, check linked() to see if it succeeded. (Calls glLinkProgram.)<br><br>

</dd>
<dt class="d_decl"><a name=".ShaderProgram.link"></a>void <a name="link"></a><span class="ddoc_psymbol">link</span>();
</dt>
<dd>Try to <a name="link"></a><span class="ddoc_psymbol">link</span>, and throw if it didn't succeed.
<br><br>
<b>Throws:</b><br>
ShaderCompilationError containing the error log on failure.<br><br>

</dd>
<dt class="d_decl"><a name=".ShaderProgram.linked"></a>const bool <a name="linked"></a><span class="ddoc_psymbol">linked</span>();
</dt>
<dd>Check if the ShaderProgram is succesfully <a name="linked"></a><span class="ddoc_psymbol">linked</span>. (Calls glGetProgramiv with GL_LINK_STATUS.)<br><br>

</dd>
<dt class="d_decl"><a name=".ShaderProgram.log"></a>const string <a name="log"></a><span class="ddoc_psymbol">log</span>();
</dt>
<dd>The <a name="log"></a><span class="ddoc_psymbol">log</span> of errors for when linking fails. (Calls glGetProgramInfoLog.)<br><br>

</dd>
<dt class="d_decl"><a name=".ShaderProgram.use"></a>void <a name="use"></a><span class="ddoc_psymbol">use</span>();
</dt>
<dd>Use this ShaderProgram. (Calls glUseProgram.)<br><br>

</dd>
<dt class="d_decl"><a name=".ShaderProgram.uniform"></a>Uniform!(T) <a name="uniform"></a><span class="ddoc_psymbol">uniform</span>(T)(const(char)* <i>name</i>);
</dt>
<dd>Look up a <a name="uniform"></a><span class="ddoc_psymbol">uniform</span> variable by its name. (Calls glGetUniformLocation.)<br><br>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Uniform"></a>struct <a name="Uniform"></a><span class="ddoc_psymbol">Uniform</span>(T);
</dt>
<dd>OpenGL uniform variable.
<br><br>
This is a wrapper around a GLuint generated by glGetUniformLocation(program, name).
<br><br>

An object of this type is returned by ShaderProgram.uniform(name).<br><br>

<dl><dt class="d_decl"><a name=".location"></a>const GLuint <a name="location"></a><span class="ddoc_psymbol">location</span>();
</dt>
<dd>The <a name="location"></a><span class="ddoc_psymbol">location</span> of this Uniform.<br><br>

</dd>
<dt class="d_decl"><a name=".set"></a>void <a name="set"></a><span class="ddoc_psymbol">set</span>(in T <i>value</i>);
</dt>
<dd>Calls the correct glUniform function, based on the type T.
<br><br>
(It calls one of:
	glUniform1f, glUniform1i, glUniform1ui, glUniform1fv, glUniform2fv,
	glUniform3fv, glUniform4fv, glUniform1iv, glUniform2iv, glUniform3iv,
	glUniform4iv, glUniform1uiV, glUniform2uiV, glUniform3uiv, glUniform4uiv,
	glUniformMatrix2fv, glUniformMatrix3fv, glUniformMatrix4fv,
	glUniformMatrix3x2fv, glUniformMatrix2x3fv, glUniformMatrix4x2fv,
	glUniformMatrix2x4fv, glUniformMatrix4x3fv,and glUniformMatrix3x4fv.)
<br><br>

	Works for GLfloat, GLint, GLuint, Matrices/Vectors/HVectors of GLfloat,
	both static and dynamic arrays of GLfloat, GLint and GLuint,
	and both static and dynamic arrays of Matrices/Vectors/Hvectors of GLfloat.<br><br>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".ShaderCompilationError"></a>class <a name="ShaderCompilationError"></a><span class="ddoc_psymbol">ShaderCompilationError</span>: object.Exception;
</dt>
<dd>The error that is thrown when Shader.compile() or ShaderProgram.link() fail.<br><br>

</dd>
</dl>

</body></html>
