<!doctype html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>moggle.math.matrix</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head><body>
<h1><a href="index.html">Moggle</a></h1>
<h2>moggle.math.matrix</h2>
<!-- Generated by Ddoc from ../source/moggle/math/matrix.d -->
<br><br>
<dl><dt class="d_decl"><a name=".Matrix"></a>struct <a name="Matrix"></a><span class="ddoc_psymbol">Matrix</span>(T, size_t N, size_t M = N);
</dt>
<dd>An N by M <a name="Matrix"></a><span class="ddoc_psymbol">Matrix</span> of T.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=green>// Matrix!(T=ElementType, N=Height, M=Width) can be initialized
</font><font color=green>// with an array of N*M elements, or by passing N*M values to the constructor.
</font><font color=blue>auto</font> m = <u>Matrix</u>!(<font color=blue>float</font>, 2, 3)(
	7, 3, 2,
	9, 1, 5,
);

<font color=green>// Elements can be accessed with [i] (i=0..N*M) and [row, column] (row=0..N, column=0..M)
</font><font color=blue>assert</font>(m[4] == 1);
<font color=blue>assert</font>(m[1, 1] == 1);
<font color=blue>assert</font>(m[0, 2] == 2);

<font color=green>// A matrix is default-initialied to just N*M default-initialized Ts.
</font>{
	<u>Matrix</u>!(<font color=blue>float</font>, 3, 3) a;
	<u>Matrix</u>!(<font color=blue>int</font>, 2, 3) b;
	<font color=blue>assert</font>(isNaN(a[2]));
	<font color=blue>assert</font>(b[2] == 0);
}

<font color=green>// .zero gives a zero-filled matrix.
</font>{
	<font color=blue>auto</font> a = <u>Matrix</u>!(<font color=blue>float</font>, 3, 3).zero;
	<font color=blue>assert</font>(a[3] == 0);
}

<font color=green>// For square matrices, .identity gives the identity matrix.
</font>{
	<font color=blue>auto</font> a = <u>Matrix</u>!(<font color=blue>float</font>, 2, 2).identity;
	<font color=green>// The identity is also accessible as a.identity.
</font>	<font color=blue>assert</font>(a[0, 0] == 1);
	<font color=blue>assert</font>(a[0, 1] == 0);
}

<font color=green>// .width and .height are aliases for N and M.
</font><font color=blue>assert</font>(<u>Matrix</u>!(<font color=blue>int</font>, 13, 37).height == 13);
<font color=blue>assert</font>(m.width == 3);

<font color=green>// [] gives a T[] slice of all N*M elements.
</font><font color=blue>assert</font>(m[] == [7, 3, 2, 9, 1, 5]);
m[] = 0;
<font color=blue>assert</font>(m == m.zero);

<font color=green>// .transposed gives the transposed M*N matrix.
</font><font color=blue>assert</font>(m.transposed.width == m.height);
<font color=blue>assert</font>(m.transposed.height == m.width);
m[0, 2] = 4;
<font color=blue>assert</font>(m.transposed[2, 0] == 4);

<font color=green>// For square matrices, .transpose() transposes the matrix in place.
</font>{
	<font color=blue>auto</font> a = <u>Matrix</u>!(<font color=blue>float</font>, 2, 2)(1, 2, 3, 4);
	a.transpose();
	<font color=blue>assert</font>(a[] == [1, 3, 2, 4]);
}

<font color=green>// Vectors are just matrices with a width of 1. Vector!(T, N) is just an alias.
</font><font color=blue>assert</font>(<font color=blue>is</font>(Vector!(<font color=blue>float</font>, 3) == <u>Matrix</u>!(<font color=blue>float</font>, 3, 1)));

<font color=green>// For vectors, [i..j] can be used to get/set/modify a part of the vector.
</font><font color=blue>auto</font> a = Vector!(<font color=blue>float</font>, 4).zero;
a[0..2] = 1;
a[1..3] += 2;
<font color=blue>assert</font>(a[0..3] == [1, 3, 2]);

<font color=green>// Vectors of different sizes can be used together, they're padded with zeros.
</font>a += Vector!(<font color=blue>float</font>, 2)(1, 2);
<font color=blue>assert</font>(a[] == [2, 5, 2, 0]);
<font color=blue>assert</font>((a - Vector!(<font color=blue>float</font>, 5)(0, 0, 0, 0, 1))[] == [2, 5, 2, 0, -1]);

<font color=green>// .column(i) and .row(i) give you a specific row or column as N*1 or 1*M matrix, respectively.
</font><font color=blue>assert</font>(m.row(0)[] == [0, 0, 4]);
<font color=blue>assert</font>(m.column(2)[] == [4, 0]);
<font color=blue>assert</font>(m.row(0).height == 1);
<font color=blue>assert</font>(m.column(0).width == 1);

<font color=green>// .without_row(i), .without_column(i), and .without_row_column(r, c) do as they say.
</font><font color=blue>assert</font>(m.without_column(1) == <u>Matrix</u>!(<font color=blue>float</font>, 2, 2)(0, 4, 0, 0));
<font color=blue>assert</font>(m.without_row(1) == <u>Matrix</u>!(<font color=blue>float</font>, 1, 3)(0, 0, 4));
<font color=blue>assert</font>(m.without_row_column(1, 1) == <u>Matrix</u>!(<font color=blue>float</font>, 1, 2)(0, 4));

<font color=green>// For (column) vectors, .length gives the Euclidian length,
</font><font color=green>// .normalized and .normalize do what you want.
</font>Vector!(<font color=blue>float</font>, 2) v = [3, 4];
<font color=blue>assert</font>(v.length == 5);
<font color=blue>assert</font>(v.normalized == Vector!(<font color=blue>float</font>, 2)(0.6, 0.8));
v.normalize();
<font color=blue>assert</font>(v.length == 1);

<font color=green>// For square matrices, there is .determinant, .cofactor(row, column),
</font><font color=green>// .cofactor_matrix, .adjugate, .inverse and .invert.
</font><u>Matrix</u>!(<font color=blue>float</font>, 3, 3) x = [
	1, 2, 3,
	0, 6, 1,
	0, 5, 0,
];
<font color=blue>assert</font>(x.determinant == -5);
<font color=blue>assert</font>(x.cofactor(1, 0) == -x.without_row_column(1, 0).determinant);
<font color=blue>assert</font>(x.cofactor_matrix[1, 0] == x.cofactor(1, 0));
<font color=blue>assert</font>(x.adjugate == x.cofactor_matrix.transposed);
<font color=blue>assert</font>(x.inverse == x.adjugate / x.determinant);
x.invert();
<font color=blue>assert</font>(x.column(1)[] == [-3, 0, 1]);

<font color=green>// You can add and subtract same-sized matrices with +=, -=, + and -,
</font><font color=green>// and scale them with *=, /=, *, and /.
</font><font color=blue>auto</font> y = x.without_row(2) + m;
y -= -m * 2;
y /= 0.5;
<font color=blue>assert</font>(y[1] == -6);

<font color=green>// Matrix multiplication is done with * and *=.
</font><font color=blue>assert</font>(x * x.inverse == x.identity);
x *= x.inverse;
<font color=blue>assert</font>(x == x.identity);

<font color=green>// For vectors, * gives you the dot product.
</font><font color=blue>assert</font>(v * v == 1);

<font color=green>// There are aliases available for the most common matrices and vectors.
</font><font color=green>// (1..4 in size, for types int, float, double and real.)
</font><font color=blue>assert</font>(<font color=blue>is</font>(Matrix2x3f == <u>Matrix</u>!(<font color=blue>float</font>, 2, 3)));
<font color=blue>assert</font>(<font color=blue>is</font>(Matrix3d == <u>Matrix</u>!(<font color=blue>double</font>, 3, 3)));
<font color=blue>assert</font>(<font color=blue>is</font>(Vector2i == Vector!(<font color=blue>int</font>, 2)));
<font color=blue>assert</font>(<font color=blue>is</font>(HVector4r == HVector!(<font color=blue>real</font>, 4)));
</pre>
<br><br>
</dd>
<dt class="d_decl"><a name=".Vector"></a>template <a name="Vector"></a><span class="ddoc_psymbol">Vector</span>(T, size_t N)</dt>
<dd>Alias for a Matrix with a width of 1.<br><br>

</dd>
<dt class="d_decl"><a name=".HVector"></a>struct <a name="HVector"></a><span class="ddoc_psymbol">HVector</span>(T, size_t N);
</dt>
<dd>A 'homogeneous vector': A vector with the last element set to 1 by default.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=green>// A HVector is a Vector with the last element set to 1 by default.
</font><font color=green>// This is handy for 4D representations of positions in 3D graphics
</font><font color=green>// and RGBA color vectors.
</font><font color=blue>auto</font> h = HVector4d(1, 0.3, 0.4);
<font color=blue>assert</font>(h[] == [1, 0.3, 0.4, 1]);
h = [0, 2, 3];
<font color=blue>assert</font>(h[] == [0, 2, 3, 1]);

<font color=green>// They can be converted back and forth to normal vectors.
</font>Vector4d v = h;
HVector4d h1 = w;
HVector4d h2 = Vector3d(1, 2, 3);
h = v;
v = h;
h += v;
</pre>
<br><br>
</dd>
</dl>

</body></html>
