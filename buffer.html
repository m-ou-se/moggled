<!doctype html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>moggle.xxx.buffer</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head><body>
<h1><a href="index.html">Moggle</a></h1>
<h2>moggle.xxx.buffer</h2>
<!-- Generated by Ddoc from moggle/xxx/buffer.d -->
<br><br>
<dl><dt class="d_decl"><a name=".Buffer"></a>class <a name="Buffer"></a><span class="ddoc_psymbol">Buffer</span>(T): GenericBuffer;
</dt>
<dd>Manages a OpenGL vertex buffer object (Vbo).
<br><br>
Contains both a Vbo!T object and a T[], which it can keep in sync.
<br><br>

Basically, a Vbo!T has data stored in the GPU memory (for OpenGL),
while the T[] has data stored in the CPU memory (for us).
If you modify the T[] and want the changes to be reflected on the GPU,
call markDirty(). Then, the next call to sync() will (re)upload the data to the GPU.
If you don't want to keep a copy of the data in the CPU memory, just empty the T[]
and don't call markDirty().
syncBack() can be used to download the data again from the GPU into the CPU memory.
<br><br>

Note that a Vbo!T is only allocated on the GPU (in OpenGL) the first time it is used.
So until the first time sync() uploads the data, there is nothing allocated in OpenGL,
not even an empty Vbo. (Unless vbo.create() is called explicitly, of course.)<br><br>

<dl><dt class="d_decl"><a name=".vbo"></a>inout @property ref auto <a name="vbo"></a><span class="ddoc_psymbol">vbo</span>();
</dt>
<dd>The Vbo!T holding the GPU's (OpenGL's) copy of the data.<br><br>

</dd>
<dt class="d_decl"><a name=".data"></a>T[] <a name="data"></a><span class="ddoc_psymbol">data</span>;
</dt>
<dd>The T[] containing the CPU's (our) copy of the <a name="data"></a><span class="ddoc_psymbol">data</span>.
<br><br>
This member is aliassed as 'this', so you can use a Buffer!T object directly
	as if it is a T[]:
<pre class="d_code"><font color=blue>auto</font> b = <font color=blue>new</font> Buffer!T([1,2,3]);
x[1] = 10;
</pre>
<br><br>

</dd>
<dt class="d_decl"><a name=".is_dirty"></a>const bool <a name="is_dirty"></a><span class="ddoc_psymbol">is_dirty</span>();
</dt>
<dd>Check if the Buffer is marked as dirty. (i.e. sync() would do anything.)<br><br>

</dd>
<dt class="d_decl"><a name=".markDirty"></a>void <a name="markDirty"></a><span class="ddoc_psymbol">markDirty</span>();
</dt>
<dd>Mark the Buffer as dirty, such that the next call to sync() will upload the data to the GPU memory.<br><br>

</dd>
<dt class="d_decl"><a name=".this"></a> this(T[] <i>d</i>...);
</dt>
<dd>Allocate a new Buffer to hold the given data.
<br><br>
The Buffer is directly marked as dirty if <i>d</i> is not empty.<br><br>

</dd>
<dt class="d_decl"><a name=".sync"></a>void <a name="sync"></a><span class="ddoc_psymbol">sync</span>();
</dt>
<dd>If the Buffer is marked as dirty, uploads the data from the T[] (CPU/us) to the Vbo!T (GPU/OpenGL). Resets is_dirty.<br><br>

</dd>
<dt class="d_decl"><a name=".syncBack"></a>void <a name="syncBack"></a><span class="ddoc_psymbol">syncBack</span>();
</dt>
<dd>Download the data form the Vbo!T (GPU/OpenGL) to the T[] (CPU/us).<br><br>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".GenericBuffer"></a>abstract class <a name="GenericBuffer"></a><span class="ddoc_psymbol">GenericBuffer</span>;
</dt>
<dd>The base class of all Buffer!T objects.
<br><br>
Doesn't know what type of objects are stored in the Buffer, but can still sync() it and access the Vbo.<br><br>

<dl><dt class="d_decl"><a name=".GenericBuffer.sync"></a>abstract void <a name="sync"></a><span class="ddoc_psymbol">sync</span>();
</dt>
<dd>If the Buffer is marked as dirty, uploads the data from the T[] (CPU/us) to the Vbo!T (GPU/OpenGL). Resets is_dirty.<br><br>

</dd>
<dt class="d_decl"><a name=".GenericBuffer.vbo"></a>final inout @property ref auto <a name="vbo"></a><span class="ddoc_psymbol">vbo</span>();
</dt>
<dd>The GenericVbo holding the GPU's (OpenGL's) copy of the data.<br><br>

</dd>
</dl>
</dd>
</dl>

</body></html>
